<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />

    <title>reveal.js</title>

    <link rel="stylesheet" href="css/reveal.css" />
    <link rel="stylesheet" href="css/theme/black.css" />

    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="lib/css/zenburn.css" />

    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement("link");
      link.rel = "stylesheet";
      link.type = "text/css";
      link.href = window.location.search.match(/print-pdf/gi)
        ? "css/print/pdf.css"
        : "css/print/paper.css";
      document.getElementsByTagName("head")[0].appendChild(link);
    </script>
  </head>
  <body>
    <div class="reveal">
      <div class="slides">
        <section>
          TODO : <br />
          Fulfill: First then param<br />
          Reject: Second then param<br />
          Resolve: First constructor param, can result in fulfillment or
          rejection
        </section>

        <section>
          <iframe
            class="stretch"
            data-src="http://localhost:8000/interactive-examples/pages/js/array-push.html"
          ></iframe>
        </section>

        <section>
          <iframe
            class="stretch"
            data-src="http://localhost:8000/interactive-examples/pages/js/array-concat.html"
          ></iframe>
        </section>

        <section>
          <iframe
            class="stretch"
            data-src="http://localhost:8000/interactive-examples/pages/js/array-function.html"
          ></iframe>
        </section>

        <section>
          <h1>Asynchronous javascript, from hell to paradise</h1>
          <h3>JS Sophia - 14th March, 2019</h3>
          <p>
            <small>Created by <a href="">Fred Guillaume</a></small>
          </p>
        </section>
        <section>
          <h2>Agenda</h2>
          <ol>
            <li>Sync vs Async</li>
            <li>Callbacks</li>
            <li>Promises</li>
            <li>Generators</li>
            <li>Await/async</li>
          </ol>
          <aside class="notes"></aside>
        </section>
        <section>
          <h2>Sync & async</h2>
          <p class="fragment">How do we think about</p>
          <p class="fragment">How do we read</p>
          <p class="fragment">How do we write</p>
          <p class="fragment">code ?</p>
          <aside class="notes"></aside>
        </section>
        <section>
          <h3>Our brain is synchronous</h3>
          <p>High level thinking is synchronous, single tasked</p>
          <aside class="notes"></aside>
        </section>
        <section>
          <p>Can't you multitask ? Because I can !!!</p>
          <p class="fragment">"Faking" multitasking</p>
          <p class="fragment">Lose focus</p>
          <p class="fragment">Quickly switching from one task to another</p>
          <aside class="notes"></aside>
        </section>
        <section>
          <p>How do we work best ?</p>
          <p class="fragment">Do tasks one after the another</p>
          <p class="fragment">Our brain = event loop</p>
          <aside class="notes"></aside>
        </section>
        <section>
          <h3>Event loop</h3>
          <p class="fragment">Single threaded</p>
          <p class="fragment">Run-to-completion</p>
          <p class="fragment">No parallel access</p>
          <p class="fragment">No shared memory</p>
        </section>
        <section>
          <section>
            <h3>Blocking the event loop</h3>
            <p class="fragment">
              A blocking thread will prevent any other threads from running
            </p>
            <p class="fragment">Blocks the whole stack</p>
            <p class="fragment">Use of asynchronous callbacks</p>
          </section>
          <section>
            <h2>Blocking the event loop</h2>
            <pre><code class="hljs" data-trim>
            const end = Date.now() + 5000;
            while (Date.now() < end) {
              // Expensive operation blocking the event loop
            }
            </code></pre>
          </section>
        </section>
        <section>
          <section>
            <h3>Blocking the event loop</h3>
            <p>Beware of expensive tasks</p>
            <p class="fragment">
              <code>JSON.Parse</code> & <code>JSON.stringify</code>
            </p>
            <p class="fragment">Regexp matching</p>
            <p class="fragment">Think about computation time & complexity</p>
          </section>
          <section>
            <h2>Expensive regexp</h2>
            <pre><code class="hljs" data-trim>
              app.get('/redos-me', (req, res) => {
                let filePath = req.query.filePath;
                
                // Nested quantifier, can be expensive !!!
                if (fileName.match(/(\/.+)+$/)) {
                console.log('valid path');
                }
                else {
                console.log('invalid path');
                }
                
                res.sendStatus(200);
              })
            </code></pre>
          </section>
        </section>
        <section>
          <section>
            <h2>Callbacks</h2>
            <p class="fragment">Call stack & callback queue</p>
            <p class="fragment">Avoid blocking the event loop</p>
            <p class="fragment">
              Execute code after an undefined (and unknown) amount of time
            </p>
            <p class="fragment">
              Callbacks execution are deferred later by third party code:
              inversion of control
            </p>
          </section>
          <aside class="notes">
            Note: callbacks do not avoid blocking event loop
            https://www.youtube.com/watch?v=8aGhZQkoFbQ
            http://latentflip.com/loupe/
            https://flaviocopes.com/javascript-event-loop/#blocking-the-event-loop
          </aside>
        </section>
        <section>
          <section>
            <h2>Callback hell</h2>
            <p>What is callback hell ?</p>
          </section>
          <section>
            <h2>Code nesting</h2>
            <pre><code class="hljs" data-trim>
              api.getUser(loggin, function(err, data) {
                // ...
                api.getGeoLocation(user, function(err, data) {
                  // ...
                  api.getWeather(location, function(err, data) {
                    // ...
                    api.notifyWeather(weather, function(err, data) {
                      // ...
                    });
                  });
                });
              });
            </code></pre>
          </section>
          <section>
            <iframe
              class="stretch"
              data-src="http://localhost:8000/interactive-examples/pages/js/callback-exec-order-1.html"
            ></iframe>
          </section>
          <section>
            <iframe
              class="stretch"
              data-src="http://localhost:8000/interactive-examples/pages/js/callback-exec-order-2.html"
            ></iframe>
            <p class="fragment">Complex even with simple workflows</p>
          </section>
          <section>
            <h2>Tighlty coupled callbacks</h2>
            <pre><code class="hljs" data-trim>
              api.getUser(loggin, function(err, data) {
                // ...
                api.getGeoLocation(user, function(err, data) {
                  // ...
                  api.getWeather(location, function(err, data) {
                    // ...
                    api.notifyWeather(weather, function(err, data) {
                      // ...
                    });
                  });
                });
              });
            </code></pre>
          </section>
          <section>
            <h2>Execution issues</h2>
            <p class="fragment">Executed too early</p>
            <p class="fragment">too late</p>
            <p class="fragment">never</p>
            <p class="fragment">too many times</p>
            <p class="fragment">too few times</p>
          </section>
          <section>
            <h2>Error management</h2>
            <pre><code class="hljs" data-trim>
              try{
                api.getUser(loggin, function(err, data) {
                  // ...
                  api.getGeoLocation(user, function(err, data) {
                    // ...
                    api.getWeather(location, function(err, data) {
                      // ...
                      api.notifyWeather(weather, function(err, data) {
                        // ...
                      });
                    });
                  });
                });
              }
              catch(err) {
                // Async errors not catched here !!!
              }
            </code></pre>
            <aside>
              <li class="nested">Third party code cannot be trusted</li>
              <li class="nested">Your own code cannot be trusted</li>
            </aside>
          </section>
        </section>
        <section>
          <section>
            <h3>Some solutions exists</h3>
          </section>
          <section>
            <h3>split callbacks</h3>
            <pre><code class="hljs" data-trim>
              const successCallback = (data) => console.log(data);
              const errorCallback = (error) => console.error(error);

              async(source, successCallback, errorCallback);
            </code></pre>
          </section>
          <section>
            <h3>"Error first" style</h3>
            <pre><code class="hljs" data-trim>
                async(source, function(err, data) {
                  // ...
                });
            </code></pre>
          </section>
          <section>
            <h3>Still a lot to improve</h3>
            <p class="fragment">success and error at the same time</p>
            <p class="fragment">
              lot of extra cumbersome code needed to fix all these issues
            </p>
            <aside class="notes">
              <ul>
                <li>error first => node style</li>
              </ul>
            </aside>
          </section>
        </section>
        <section>
          <section>
            <h2>Promises</h2>
            <p class="fragment">
              Callback is execution is handle by external code => IoC
            </p>
            <p class="fragment">
              What if we could uninvert that inversion of control ?
            </p>
          </section>
          <section>
            <h3 class="fragment">Promise "events"</h3>

            <pre><code class="hljs" data-trim>
              function foo(x) {
                // start doing something that could take a while

                // make a `listener` event notification
                // capability to return

                return listener;
              }

              var evt = foo( 42 );

              evt.on( "completion", function(){
                // now we can do the next step!
              } );

              evt.on( "failure", function(err){
                // oops, something went wrong in `foo(..)`
              } );
            </code></pre>
            <aside class="notes">
              Instead of passing a callback to async function, get a listener
              that will trigger when the function has finished
              <p>
                Instead, return an event-subscription capable object, with
                "completion" and "failure" events
              </p>
            </aside>
          </section>
        </section>
        <section>
          <section>
            <h3>Flow control</h3>
            <p>
              Function can be called when promise resolves, regardless if it is
              a success or a failure
            </p>
            <pre><code class="hljs" data-trim>
            function foo(promise) {
              promise.then(function() {
                // Code executed on promise fulfillment
              },function() {
                // Code executed on promise failure
              });
            }
          </code></pre>
          </section>
          <section>
            <h3>Flow control</h3>
            <p>
              Function can be called only when promise is fulfilled, or is
              rejected
            </p>
            <pre><code class="hljs" data-trim>
              promise.then(bar, errorBar);
            </code></pre>
          </section>
        </section>
        <section>
          <h3>Immutable once resolved</h3>
          <p>Once resolved, a promise is immutable</p>
        </section>
        <section>
          <h3>Thenable duck typing</h3>
          <p>
            Any object or function that has a <code>then</code> method on it
          </p>
        </section>
        <section>
          <h3>Promise & job queue</h3>
          <p>
            When calling then, the callback will always be called asynchronously
          </p>
          <p>Higher priority than callbacks</p>
          <aside>
            https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/
          </aside>
        </section>
        <section>
          <h3>Promise trust</h3>
          <h4>Call the callback too early</h4>
          <p>What happens if a promise is immediately fulfilled ?</p>
          <p>
            In any cases, the then callback will be executed asynchronously
            through the microtask queue
          </p>
          <p>
            Promise resolve synchronous & asynchronous code the same predictable
            way
          </p>
        </section>
        <section>
          <h3>Promise trust</h3>
          <h4>Call the callback too late</h4>
          <p>
            When a promise is fulfilled, every then callback registered will be
            called in order in the next microtask queue execution
          </p>
        </section>
        <section>
          <h3>Promise trust</h3>
          <h4>Callback never called</h4>
          <p>If a promise is resolved, wether it is fulfilled or not</p>
          <p>Promise.race</p>
        </section>
        <section>
          <h3>Promise trust</h3>
          <h4>Callback called too few or too many times</h4>
          <p>A promise only resolves once, after it stays immutable</p>
          <p>Then registered callbacks will only be executed once</p>
        </section>
        <section>
          <h3>Promise trust</h3>
          <h4>Parameters issues</h4>
          <p>No parameters: resolves with <code>undefined</code></p>
          <p>More than one paramter: subsequent ones are ignored</p>
        </section>
        <section>
          <h3>Promise trust</h3>
          <h4>Trustable ?</h4>
          <p>Promise.resolve</p>
          <p>
            If pass a non-thenable value, it returns a new genuine promise
            fulfilled with that value
          </p>
          <p>If pass a genuine promise value, it returns it back</p>
          <p>
            If pass a non-genuine promise value, it unwraps that value up to its
            final non-thenable value
          </p>
          <p>Promise.resolve always return a trustable genuine promise value</p>
          <aside>
            Functions that return both asynchronous & synchronous values
          </aside>
        </section>
        <section>
          <h3>Promise trust</h3>
          <h4>Chain flow</h4>
          <p>
            The value returned from a fulfillment callback is automatically set
            as the fulfillment of the next chained promise
          </p>
        </section>
        <section>
          <h3>Promise advanced</h3>
          <h4>Default handles</h4>
          <p>fulfillment</p>
          <pre><code class="hljs" data-trim>
            function(v) {
              return v;
            }
          </code></pre>
        </section>
        <section>
          <h3>Promise advanced</h3>
          <h4>Default handles</h4>
          <p>Rejection</p>
          <pre><code class="hljs" data-trim>
            function(err) {
              throw err;
            }
          </code></pre>
        </section>
        <section>
          <p>Then Fulfill handler unwrap promise value</p>
          <p>Then Error handlet does not unwrap promise value</p>
        </section>
        <section>
          <p>Swallowed errors</p>
          <p>
            If an error is thrown in then callbacks, it will affect the next
            chained promise
          </p>
          <p>Add a catch statement at the end</p>
          <p>
            Errors in that catch, what about the promise returned by the catch
            method ?
          </p>
        </section>
        <section>
          <h3>Promise patterns</h3>
          <p>Promise.all([])</p>
          <p>Argument: array of promise instances</p>
          <p>
            Fulfilled if every promise are fulfilled. If one is rejected,
            Promise.all is immediately rejected
          </p>
          <p>
            An array of every fulfillment messages is passed to the then fulfill
            callback
          </p>
          <aside>Always attach rejection handler when using all !!!</aside>
        </section>
        <section>
          <h3>Promise patterns</h3>
          <p>Promise.race([])</p>
          <p>Argument: array of promise instances</p>
          <p>
            Fulfilled when any promise fulfill, and rejected when any promise
            reject
          </p>
          <p>
            An array of every fulfillment messages is passed to the then fulfill
            callback
          </p>
        </section>
        <section>
          <h3>Promise patterns</h3>
          <p>none</p>
          <p>any</p>
          <p>first</p>
          <p>last</p>
        </section>
        <section>
          <h3>Promise limitations</h3>
          <p>Sequence error handling</p>
          <p>
            Can handle error at the end of the chain. But errors might be
            silenced inside the chain.
          </p>
          <p>Same as try/catch statement that silent an error</p>
          <p>No reference to intermediate steps</p>
          <p>Single value (must use object or array)</p>
          <p>Only single resolution</p>
          <p>Cannot be canceled</p>
          <p>
            Less performant (but more error-proof) => achieve the same with
            callbacks ?
          </p>
          <p>Code boilerplate</p>
        </section>
        <section>
          <h2>Generators</h2>
          <p>Express async flow control in a sequential style</p>
          <p>Iterator & iterable</p>
          <p class="indent">
            Iterable : Must have a Symbol.iterator function on it.
          </p>
          <p class="indent">Returns an iterator</p>
        </section>
        <section>
          <p>Multiple iterators</p>
          <p>Interleaving</p>
          <p>Terminating the generator</p>
          <p class="indent">Automatic with for..of</p>
          <p class="indent">
            Call return method on iterator to send the terminal signal. Also
            sets the returned value to the passed argument.
          </p>
          <p class="indent">
            Note that a finally clause in the generator function will always be
            called upon termination
          </p>
        </section>
        <section>
          <p>Async control flow ... in a sequential way !!! Awesome !!!</p>
          <p>
            Generator listen for a promise to resolve and then resume the
            generator with the fulfillment message or whith an error thrown
          </p>
          <p>
            Pause the generator by getting back a promise, and resume it when
            that promise fulfills or rejects !!!
          </p>
        </section>
        <section>
          <h2>Async/await</h2>
          <p>Handle the</p>
        </section>
        <section>
          <h2>Pretty Code</h2>
          <pre><code class="hljs" data-trim data-noescape>
            <mark class="hljs-custom-blur-code">function linkify( selector ) {
              if( supports3DTransforms ) {

                var nodes = document.querySelectorAll( selector );

                for( var i = 0, len = nodes.length; i &lt; len; i++ ) {</mark>
                  var node = nodes[i];

                  if( !node.className ) {
                    node.className += ' roll';
                  }
                <mark class="hljs-custom-blur-code">}
              }
            }</mark>
					</code></pre>
          <p>
            Code syntax highlighting courtesy of
            <a href="http://softwaremaniacs.org/soft/highlight/en/description/"
              >highlight.js</a
            >.
          </p>
        </section>
        <section>
          const asyncCallback = (success, error) => { const callback =
          Math.random() > .5 ? success : error; setTimeout(callback, 0,
          'Fredddy'); } asyncCallback((name)=>{ console.log(name); }, (name)=>{
          console.log('error'); })
        </section>
      </div>
    </div>

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.js"></script>

    <script>
      // More info about config & dependencies:
      // - https://github.com/hakimel/reveal.js#configuration
      // - https://github.com/hakimel/reveal.js#dependencies

      // Shows the slide number using default formatting
      Reveal.configure({ slideNumber: true });

      Reveal.initialize({
        dependencies: [
          {
            src: "plugin/highlight/highlight.js",
            async: true,
            callback: function() {
              hljs.initHighlightingOnLoad();
            }
          },
          { src: "plugin/notes/notes.js", async: true },
          {
            src: "plugin/highlight/highlight.js",
            async: true,
            callback: function() {
              hljs.initHighlightingOnLoad();
            }
          }
        ]
      });
    </script>
  </body>
</html>
